generator client {
    provider        = "prisma-client"
    output          = "../src/generated/prisma"
    previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
    provider = "postgresql"
}

enum SupportStatus {
    PENDING
    IN_PROGRESS
    RESOLVED
    REJECTED
}

enum TargetType {
    topic
    token
}

enum Status {
    SENT
    FAILED
}

model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    userId       String
    expires      DateTime
    sessionToken String   @unique
    accessToken  String   @unique
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    id         String    @id @default(cuid())
    identifier String?
    userId     String?
    token      String    @unique
    expires    DateTime?
    user       User?     @relation(fields: [userId], references: [id])

    @@unique([identifier, token])
}

model User {
    id                 String              @id @default(cuid())
    name               String
    email              String?
    mobile             String              @unique
    emailVerified      DateTime?
    password           String
    address            String?
    city               String?
    state              String?
    image              String?
    userRole           String
    userStatus         String?
    fcmToken           String?
    createdAt          DateTime            @default(now())
    updatedAt          DateTime?
    accounts           Account[]
    sessions           Session[]
    verificationTokens VerificationToken[]
    supports           Support[]
    tokens             Token[]
    jobPostedBy        Job[]               @relation("JobPostedBy")
    jobFinishedBy      Job[]               @relation("JobFinishedBy")

    // Relations for the universal chat
    chatsAsUser1 ChatSession[] @relation("ChatUser1")
    chatsAsUser2 ChatSession[] @relation("ChatUser2")
    messagesSent ChatMessage[]
}

model Support {
    id         String        @id @default(uuid())
    mobile     String
    queryType  String
    message    String
    photo      String? // The proof image URL
    status     SupportStatus @default(PENDING)
    adminReply String?
    resolvedAt DateTime?
    createdAt  DateTime      @default(now())
    updatedAt  DateTime      @updatedAt
    postedBy   User          @relation(fields: [postedById], references: [mobile])
    postedById String
}

model Job {
    id            Int       @id @default(autoincrement())
    description   String?
    category      String?
    location      String
    paymentStatus String    @default("PENDING")
    status        String    @default("ACTIVE")
    cost          String
    jobPhoto      String
    jobPhotoDone  String?
    createdAt     DateTime  @default(now())
    finishedAt    DateTime?
    postedBy      User      @relation("JobPostedBy", fields: [postedById], references: [mobile])
    postedById    String
    finishedBy    User?     @relation("JobFinishedBy", fields: [finishedById], references: [mobile])
    finishedById  String?
}

model Token {
    id           Int       @id @default(autoincrement())
    orderNumber  String
    mobileNumber String
    orderCode    String
    quantity     Int?
    tokenCode    String
    tokenStatus  String    @default("REQUESTED")
    createdAt    DateTime  @default(now())
    receivedAt   DateTime?
    postedBy     User?     @relation(fields: [postedById], references: [mobile])
    postedById   String?

    @@index([createdAt])
}

model Order {
    id                Int       @id @default(autoincrement())
    orderNumber       String    @unique
    email             String
    name              String
    address           String?
    city              String?
    state             String?
    pincode           String?
    description       String?
    mobile            String?
    amount            String?
    discount          String?
    shipping          String?
    totalAmount       String?
    orderItem         Json
    orderStatus       String?
    paymentId         String?
    paymentStatus     String?
    orderDate         DateTime  @default(now())
    orderDispatchDate DateTime?
}

model Subscription {
    id       String @id @default(uuid())
    endpoint String @unique // The unique URL for the user's browser
    p256dh   String // Public key for encryption
    auth     String // Auth secret

    // Optional: Link to a User/Admin if you have authentication
    // userId    String? 
    // user      User?   @relation(fields: [userId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model NotificationLog {
    id           String     @id @default(uuid())
    title        String
    body         String
    targetType   TargetType
    target       String
    status       Status     @default(SENT)
    messageId    String?
    sentAt       DateTime   @default(now())
    errorDetails String?

    @@index([sentAt]) // Optimize sorting by date
}

model ChatSession {
    id String @id @default(cuid())

    // The alphabetically smaller ID always goes here
    user1Id String
    user1   User   @relation("ChatUser1", fields: [user1Id], references: [id])

    // The alphabetically larger ID always goes here
    user2Id String
    user2   User   @relation("ChatUser2", fields: [user2Id], references: [id])

    status   String        @default("OPEN")
    messages ChatMessage[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // CRITICAL: This perfectly ensures only ONE chat thread exists between ANY two users
    @@unique([user1Id, user2Id])
}

// model ChatMessage {
//   id     String  @id @default(cuid())
//   text   String
//   isRead Boolean @default(false)

//   senderId String
//   sender   User   @relation(fields: [senderId], references: [id])

//   chatSessionId String
//   session       ChatSession @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)

//   readAt    DateTime?
//   createdAt DateTime  @default(now())
// }

model ChatMessage {
    id            String    @id @default(cuid())
    chatSessionId String
    senderId      String
    text          String? // Made optional for image-only messages
    imageUrl      String? // Added for images
    isRead        Boolean   @default(false)
    readAt        DateTime?
    createdAt     DateTime  @default(now())

    // Self-relation for replies
    replyToId String?
    replyTo   ChatMessage?  @relation("MessageReplies", fields: [replyToId], references: [id])
    replies   ChatMessage[] @relation("MessageReplies")

    session ChatSession @relation(fields: [chatSessionId], references: [id])
    sender  User        @relation(fields: [senderId], references: [id])
}
